// theF.cpp : This file contains the 'main' function. Program execution begins and ends there.
// Solution : for evey 2 consecutive points p[i], p[i + 1] use the distToLineSegment function where p = m(the given point), a = p[i], b = p[i + 1] and c = an arbitrary point just to retrieve the best point
// easy problem, ugly implementation

#include <bits/stdc++.h>
// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
#define vi std::vector<int>
#define ii std::pair<int,int>
#define INF (1e9 + 5)
#define no std::cout << "NO" << '\n'
#define yes std::cout << "YES" << '\n'
#define fastio std::ios_base::sync_with_stdio(0); std::cin.tie(0);
#define UNVISITED (-1)
#define VISITED 1
#define EXPLORED 2
#define vii std::vector<ii>
#define LSOne(S) ((S) &-(S))

const int MOD = 1e9 + 7;

// using namespace __gnu_pbds;
// typedef tree<std::pair<int,int>, null_type, std::less<std::pair<int,int>>, rb_tree_tag,
//               tree_order_statistics_node_update>
//      oset;

struct point {
    double x, y;
    point() : x(0), y(0) {}
    point(double _x, double _y) : x(_x), y(_y) {}
};

struct vec {
    double x, y;
    vec (double _x, double _y) : x(_x), y(_y) {}
};

vec toVec(point a, point b) {
    return {b.x - a.x, b.y - a.y};
}

double dot(vec a, vec b) {
    return {a.x * b.x + a.y * b.y};
}

double norm_sq(vec a) {
    return dot(a, a);
}

double dist(point a, point b) {
    return sqrt(std::pow((b.x - a.x), 2) + std::pow((b.y - a.y), 2));
}

vec scale(vec a, double u) {
    return {a.x * u, a.y * u};
}

point translate(point a, vec b) {
    return {a.x + b.x, a.y + b.y};
}

double distToLine(point p, point a, point b, point &c) {
    vec ab(toVec(a, b)), ap(toVec(a, p));
    double u = dot(ab, ap) / norm_sq(ab);
    c = translate(a, scale(ab, u));
    point temp = c;
    return dist(p, temp);
}

double distToLineSegment(point p, point a, point b, point &c) {
    vec ab(toVec(a, b)) ,ap(toVec(a,p));
    double u = dot(ab, ap) / norm_sq(ab);
    if (u < 0.0) {
        c = a;
        return dist(p,a);
    }else if (u > 1.0) {
        c = b;
        return dist(p, b);
    }
    return distToLine(p, a, b, c);
}


int main() {
    double Xm,Ym;
    while(scanf("%lf", &Xm) == 1) {
        scanf("%lf", &Ym);
        point p(Xm, Ym);
        int N; scanf("%d", &N);
        std::vector<point> points(N + 1);

        for (int i = 0; i < N + 1; ++i) {
            double x,y; scanf("%lf %lf", &x, &y);
            points[i] = point(x,y);
        }
        double ans = 1e18;
        point pans(-1e18, -1e18);

        for (int i = 1; i < N + 1; ++i) {
            point tempc(-1e18, -1e18);
            double anstemp = distToLineSegment(p, points[i - 1], points[i], tempc);
            if (anstemp < ans) {
                ans = anstemp;
                pans = tempc;
            }
        }

        printf("%0.4lf\n%0.4lf\n", pans.x, pans.y);
    }
}




/*
6
-3
3
0
1
5
5
9
-5
15
3
0
0
1
1
0
2
0
*/
// Run program: Ctrl + F5 or Debug > Start Without Debugging menu
// Debug program: F5 or Debug > Start Debugging menu

// Tips for Getting Started:
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln fi
